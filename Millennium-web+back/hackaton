import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import folium
from folium import plugins
import requests
from typing import List, Dict, Tuple
import json
from datetime import datetime

class RealEstateRecommender:
    def __init__(self, api_key=None):
        """
        Initialize the recommender system
        """
        self.api_key = api_key
        self.facilities_weight = {
            'school': 1.5,
            'hospital': 1.8,
            'supermarket': 1.2,
            'cafe': 0.8,
            'park': 1.0,
            'transit_station': 1.3,
            'shopping_mall': 1.1
        }
        
    def get_nearby_facilities(self, location: Tuple[float, float], 
                             radius: int = 1000) -> Dict:
        """
        Get nearby facilities using OpenStreetMap (free, no API key needed)
        """
        lat, lon = location
        
        # Using Overpass API (free, no key required)
        facilities = {facility: 0 for facility in self.facilities_weight.keys()}
        
        # Map our facility types to OSM tags
        osm_tags = {
            'school': 'amenity=school',
            'hospital': 'amenity=hospital',
            'supermarket': 'shop=supermarket',
            'cafe': 'amenity=cafe',
            'park': 'leisure=park',
            'transit_station': 'public_transport=station',
            'shopping_mall': 'shop=mall'
        }
        
        try:
            for facility, tag in osm_tags.items():
                # Overpass API query
                overpass_url = "http://overpass-api.de/api/interpreter"
                query = f"""
                [out:json];
                (
                  node[{tag}](around:{radius},{lat},{lon});
                  way[{tag}](around:{radius},{lat},{lon});
                  relation[{tag}](around:{radius},{lat},{lon});
                );
                out count;
                """
                
                response = requests.get(overpass_url, params={'data': query})
                if response.status_code == 200:
                    result = response.json()
                    # Extract count from result
                    if 'elements' in result and len(result['elements']) > 0:
                        facilities[facility] = result['elements'][0].get('tags', {}).get('total', 0)
        
        except:
            # Fallback to mock data if API fails
            facilities = self._generate_mock_facilities(location)
        
        return facilities
    
    def _generate_mock_facilities(self, location: Tuple[float, float]) -> Dict:
        """Generate mock facilities data for demonstration"""
        lat, lon = location
        facilities = {}
        
        # Use location as seed for consistent random data
        seed = int(abs(lat * 1000 + lon * 1000))
        np.random.seed(seed)
        
        for facility in self.facilities_weight.keys():
            # Generate random counts
            if abs(lat - 40.7128) < 1 and abs(lon - (-74.0060)) < 1:  # NYC
                facilities[facility] = np.random.randint(5, 15)
            elif abs(lat - 51.5074) < 1 and abs(lon - (-0.1278)) < 1:  # London
                facilities[facility] = np.random.randint(3, 12)
            else:
                facilities[facility] = np.random.randint(0, 8)
        
        return facilities
    
    def calculate_location_score(self, facilities: Dict) -> float:
        """
        Calculate score based on nearby facilities
        """
        if not facilities:
            return 0
        
        score = 0
        total_weight = 0
        
        for facility, count in facilities.items():
            weight = self.facilities_weight.get(facility, 1.0)
            normalized_count = min(count / 10, 1.0)  # Cap at 10 facilities
            score += normalized_count * weight
            total_weight += weight
        
        return score / total_weight if total_weight > 0 else 0
    
    def analyze_area_grid(self, center: Tuple[float, float], 
                         grid_size: int = 3,
                         cell_size_km: float = 1.0) -> pd.DataFrame:
        """
        Analyze multiple locations in a grid
        """
        lat, lon = center
        
        # 1 degree latitude ‚âà 111 km
        lat_step = cell_size_km / 111
        # 1 degree longitude varies with latitude
        lon_step = cell_size_km / (111 * np.cos(np.radians(lat)))
        
        data = []
        
        for i in range(-grid_size, grid_size + 1):
            for j in range(-grid_size, grid_size + 1):
                current_lat = lat + (i * lat_step)
                current_lon = lon + (j * lon_step)
                
                facilities = self.get_nearby_facilities((current_lat, current_lon))
                score = self.calculate_location_score(facilities)
                
                record = {
                    'latitude': current_lat,
                    'longitude': current_lon,
                    'score': score
                }
                record.update(facilities)
                
                data.append(record)
        
        return pd.DataFrame(data)
    
    def create_visualization(self, df: pd.DataFrame, center: Tuple[float, float]):
        """
        Create visualizations
        """
        # Create interactive map
        m = folium.Map(location=center, zoom_start=13)
        
        # Add heatmap
        heat_data = [[row['latitude'], row['longitude'], row['score']] 
                    for _, row in df.iterrows()]
        
        plugins.HeatMap(
            heat_data,
            min_opacity=0.3,
            max_opacity=0.8,
            radius=20,
            blur=10,
            gradient={
                0.0: 'red',
                0.5: 'yellow',
                0.7: 'lightgreen',
                1.0: 'darkgreen'
            }
        ).add_to(m)
        
        # Add markers for top locations
        top_locations = df.nlargest(5, 'score')
        
        for _, row in top_locations.iterrows():
            # Create color based on score
            if row['score'] > 0.7:
                color = 'green'
            elif row['score'] > 0.4:
                color = 'orange'
            else:
                color = 'red'
            
            # Create popup content
            popup_content = f"""
            <b>Location Score: {row['score']:.2f}</b><br>
            Coordinates: ({row['latitude']:.4f}, {row['longitude']:.4f})<br>
            <hr>
            <b>Nearby Facilities:</b><br>
            """
            
            for facility in self.facilities_weight.keys():
                if facility in row and row[facility] > 0:
                    popup_content += f"‚Ä¢ {facility.title()}: {int(row[facility])}<br>"
            
            folium.CircleMarker(
                location=[row['latitude'], row['longitude']],
                radius=8,
                popup=folium.Popup(popup_content, max_width=300),
                color=color,
                fill=True,
                fill_color=color
            ).add_to(m)
        
        # Save map
        m.save('real_estate_heatmap.html')
        
        # Create score distribution chart
        plt.figure(figsize=(10, 6))
        
        plt.subplot(1, 2, 1)
        plt.hist(df['score'], bins=10, color='skyblue', edgecolor='black')
        plt.title('Score Distribution')
        plt.xlabel('Score')
        plt.ylabel('Frequency')
        
        plt.subplot(1, 2, 2)
        # Scatter plot of locations
        scatter = plt.scatter(df['longitude'], df['latitude'], 
                             c=df['score'], cmap='RdYlGn', 
                             s=100, alpha=0.7)
        plt.colorbar(scatter, label='Score')
        plt.title('Location Scores')
        plt.xlabel('Longitude')
        plt.ylabel('Latitude')
        
        plt.tight_layout()
        plt.savefig('score_analysis.png', dpi=100)
        plt.show()
        
        return m
    
    def generate_report(self, df: pd.DataFrame):
        """
        Generate HTML report
        """
        # Sort by score
        df_sorted = df.sort_values('score', ascending=False)
        
        # Create HTML
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Real Estate Location Analysis</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ 
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white; 
                    padding: 20px; 
                    border-radius: 10px;
                    margin-bottom: 20px;
                }}
                .score-card {{
                    background: white;
                    border-radius: 8px;
                    padding: 15px;
                    margin: 10px 0;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    border-left: 4px solid #4CAF50;
                }}
                .low-score {{ border-left-color: #f44336; }}
                .medium-score {{ border-left-color: #ff9800; }}
                .high-score {{ border-left-color: #4CAF50; }}
                table {{
                    width: 100%;
                    border-collapse: collapse;
                    margin: 20px 0;
                }}
                th, td {{
                    padding: 12px;
                    text-align: left;
                    border-bottom: 1px solid #ddd;
                }}
                th {{
                    background-color: #f2f2f2;
                }}
                .score {{
                    font-size: 20px;
                    font-weight: bold;
                    color: #2196F3;
                }}
                .good { color: #4CAF50; }
                .average { color: #FF9800; }
                .poor { color: #F44336; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>üè† Real Estate Location Analysis</h1>
                <p>Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            </div>
            
            <h2>üìä Analysis Summary</h2>
            <p>Total locations analyzed: {len(df)}</p>
            <p>Average score: <span class="score">{df['score'].mean():.3f}</span></p>
            <p>Best score: <span class="score good">{df['score'].max():.3f}</span></p>
            <p>Worst score: <span class="score poor">{df['score'].min():.3f}</span></p>
            
            <h2>üèÜ Top 5 Locations</h2>
        """
        
        # Add top locations
        for idx, (_, row) in enumerate(df_sorted.head().iterrows(), 1):
            score_class = "good" if row['score'] > 0.7 else "average" if row['score'] > 0.4 else "poor"
            html_content += f"""
            <div class="score-card {score_class}-score">
                <h3>#{idx} - Score: <span class="{score_class}">{row['score']:.3f}</span></h3>
                <p>Coordinates: {row['latitude']:.4f}, {row['longitude']:.4f}</p>
                <p><b>Nearby Facilities:</b></p>
                <ul>
            """
            
            for facility in self.facilities_weight.keys():
                if facility in row and row[facility] > 0:
                    html_content += f"<li>{facility.title()}: {int(row[facility])}</li>"
            
            html_content += """
                </ul>
            </div>
            """
        
        # Add data table
        html_content += f"""
            <h2>üìã All Locations</h2>
            {df_sorted.to_html(classes='dataframe', index=False)}
            
            <h2>üìà Visualizations</h2>
            <p><b>Heat Map:</b> Open <a href="real_estate_heatmap.html">real_estate_heatmap.html</a></p>
            <p><b>Score Analysis:</b> See <a href="score_analysis.png">score_analysis.png</a></p>
            
            <div style="margin-top: 40px; padding: 20px; background: #f9f9f9; border-radius: 5px;">
                <h3>üéØ Scoring Legend</h3>
                <p><span style="color: #4CAF50; font-weight: bold;">Green (0.7-1.0):</span> Excellent location with great facilities</p>
                <p><span style="color: #FF9800; font-weight: bold;">Yellow (0.4-0.7):</span> Good location with adequate facilities</p>
                <p><span style="color: #F44336; font-weight: bold;">Red (0.0-0.4):</span> Needs improvement in facilities</p>
            </div>
        </body>
        </html>
        """
        
        with open('real_estate_report.html', 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        print("‚úÖ Report generated: real_estate_report.html")


# Simple example usage
def main():
    print("üöÄ Starting Real Estate Location Analysis...")
    
    # Initialize with no API key needed
    recommender = RealEstateRecommender()
    
    # Choose a location to analyze
    # Example: New York City
    location = (40.7128, -74.0060)
    
    print(f"\nüìç Analyzing area around coordinates: {location}")
    print("This may take a moment as we fetch facility data...\n")
    
    # Analyze the area
    analysis_df = recommender.analyze_area_grid(
        center=location,
        grid_size=2,  # 5x5 grid
        cell_size_km=1.0  # 1km between points
    )
    
    # Display quick summary
    print("=" * 50)
    print("QUICK SUMMARY")
    print("=" * 50)
    print(f"Locations analyzed: {len(analysis_df)}")
    print(f"Best score found: {analysis_df['score'].max():.3f}")
    print(f"Average score: {analysis_df['score'].mean():.3f}")
    print(f"Top 3 locations:")
    
    for idx, (_, row) in enumerate(analysis_df.nlargest(3, 'score').iterrows(), 1):
        print(f"\n  {idx}. Score: {row['score']:.3f}")
        print(f"     Coordinates: ({row['latitude']:.4f}, {row['longitude']:.4f})")
        print(f"     Key facilities:")
        
        # Show top 3 facilities for this location
        facility_counts = []
        for facility in recommender.facilities_weight.keys():
            if facility in row and row[facility] > 0:
                facility_counts.append((facility, row[facility]))
        
        facility_counts.sort(key=lambda x: x[1], reverse=True)
        for facility, count in facility_counts[:3]:
            print(f"       ‚Ä¢ {facility}: {int(count)}")
    
    # Create visualizations
    print("\n" + "=" * 50)
    print("Creating visualizations...")
    recommender.create_visualization(analysis_df, location)
    
    # Generate report
    recommender.generate_report(analysis_df)
    
    print("\n" + "=" * 50)
    print("‚úÖ ANALYSIS COMPLETE!")
    print("=" * 50)
    print("\nüìÅ Generated files:")
    print("   ‚Ä¢ real_estate_heatmap.html - Interactive map (green=good, red=poor)")
    print("   ‚Ä¢ real_estate_report.html - Detailed analysis report")
    print("   ‚Ä¢ score_analysis.png - Score distribution charts")
    
    print("\nüîç Open real_estate_heatmap.html in your browser to see the heatmap!")
    print("   Green areas indicate the best locations to live!")
    print("=" * 50)


if __name__ == "__main__":
    main()